WORKFLOW STANDARD (Codex + ChatGPT) – Zero casino

OBIETTIVO
Usare Codex per leggere e applicare patch mirate sul repo, mantenendo controllo totale su:
- file toccati
- chiavi Firestore
- logica invariata
- rollback immediato

────────────────────────────────────────────────────────────
FASE 0 — PRE-SICUREZZA (prima di qualsiasi patch)
[ ] Working tree pulito (nessun file modificato non voluto).
[ ] Se ci sono modifiche locali importanti, fai commit SOLO dopo test.
[ ] Se task è rischioso: crea branch temporaneo oppure copia dei file target.

Rollback rapido (solo tu):
- VS Code: Source Control → Discard Changes (solo file target)
- oppure: git restore <file1> <file2> ...

────────────────────────────────────────────────────────────
FASE 1 — LETTURA E MAPPA (Codex in sola lettura)
Istruzione per Codex:
1) Leggi i file richiesti.
2) NON applicare patch.
3) Produci solo:
   - mappa file/funzioni coinvolte
   - mappa chiavi lette/scritte (@...)
   - shape dati principali (campi record)
   - rischi/mismatch writer vs reader

Output atteso:
- elenco file analizzati
- elenco chiavi Firestore/localStorage
- 5-10 punti massimo di conclusioni tecniche

Checkpoint:
[ ] La mappa corrisponde a quello che vedo nel progetto.
[ ] Nessuna supposizione. Solo cose verificabili nel codice.

────────────────────────────────────────────────────────────
FASE 2 — SPECIFICA (ChatGPT + Requisiti testabili)
Prima di far scrivere Codex:
[ ] Definire obiettivo in 1 frase.
[ ] Definire “DONE” (criteri verificabili in locale).
[ ] Definire vincoli:
    - file ammessi alla scrittura (whitelist)
    - file vietati
    - chiavi vietate da cambiare
    - niente refactor / niente rinominare / niente pulizie
[ ] Definire test manuale (5-10 passi).

Esempio DONE:
- “Clic MODIFICA apre modale, salva per id, persiste dopo refresh, nessun file extra toccato”.

────────────────────────────────────────────────────────────
FASE 3 — PATCH PICCOLA (Codex in scrittura controllata)
Regola d’oro:
Codex deve SEMPRE fare prima un PIANO breve, poi la patch.

Istruzione per Codex (template):
- Puoi leggere tutto il repo che serve.
- Puoi scrivere SOLO sui file ammessi.
- NON eseguire comandi shell (npm/vite/tsc/firebase ecc).
- NON usare git (no commit/push/checkout/restore).
- Prima: piano in max 10 bullet + lista file toccati.
- Poi: applica patch e mostra diff completo.

Checkpoint prima di approvare patch:
[ ] File toccati = SOLO quelli ammessi.
[ ] Nessuna dipendenza nuova.
[ ] Nessuna modifica a chiavi Firestore non richiesta.
[ ] Nessuna modifica a routing/app shell non richiesta.
[ ] Nessun refactor massivo.

────────────────────────────────────────────────────────────
FASE 4 — VERIFICA TECNICA RAPIDA (CTRL+F)
Prima del test UI, verifica 5 cose nel codice (solo ricerca testo):
[ ] setItemSync/getItemSync usa la chiave giusta (@...).
[ ] Update per id: findIndex/find con record.id.
[ ] Non perde campi: usa spread (...old, ...draft) o patch mirata.
[ ] Timestamp: normalizzazione (timestamp ?? data ?? ...) se serve.
[ ] Nessun import sospetto / codice morto enorme.

────────────────────────────────────────────────────────────
FASE 5 — TEST LOCALE (manuale, breve)
Esegui SEMPRE questi test minimi:
[ ] Compila e parte in locale.
[ ] Flusso principale: la feature richiesta funziona.
[ ] Refresh pagina: i dati restano corretti.
[ ] Caso negativo: input mancante mostra errore o non rompe.
[ ] Mobile width: nessun overflow evidente (se UI).

Checklist test da scrivere per ogni task:
1) ...
2) ...
3) ...

────────────────────────────────────────────────────────────
FASE 6 — DECISIONE
Se OK:
[ ] Solo dopo test locale: commit con messaggio chiaro.
[ ] Push quando hai verificato.

Se NON OK:
[ ] Rollback immediato (discard o git restore file target).
[ ] Ripeti con patch più piccola e vincoli più stretti.

────────────────────────────────────────────────────────────
REGOLE ASSOLUTE
- Niente “patch giganti” su 10+ file.
- Prima leggere e capire, poi scrivere.
- Un problema alla volta.
- Mai cambiare chiavi o data model se non richiesto.
- Se qualcosa è ambiguo: stop e piano, non patch.
CODEX — LETTURA LIBERA, SCRITTURA BLINDATA (REGOLA PERMANENTE)

PRINCIPIO
- Codex può LEGGERE qualunque file del progetto per capire contesto.
- Codex può SCRIVERE solo dentro una WHITELIST di file dichiarata PRIMA della patch.
- Quando gli chiediamo di applicare modifiche, NON deve chiedere ogni volta “acconsenti”.
  Se whitelist ok e file esistono: applica direttamente la patch.
  Se serve un file fuori whitelist: STOP e scrivi “SERVE FILE EXTRA: <path>” senza modificare nulla.

OBBLIGO OPERATIVO NEI PROMPT
- Ogni prompt a Codex DEVE includere i comandi per raggiungere cartelle e file (pwd/ls/rg).
  Se non li includiamo, Codex spesso non segue o non trova i file corretti.
- Codex deve stampare SEMPRE i path reali dei file che userà per la patch.

PRE-CHECK (PRIMA DI LANCIARE CODEX)
- Salvare i file in VS Code (se non sono salvati, Codex non li vede).
- Far confermare a Codex la cartella di lavoro con:
  1) pwd
  2) ls
  3) ls src

TEMPLATE PROMPT (LETTURA LIBERA + PATCH BLINDATA)

OBIETTIVO
[Descrivi in 1–3 righe cosa deve cambiare.]

REGOLE DI ACCESSO
- LETTURA: puoi leggere QUALSIASI file nel progetto.
- SCRITTURA: puoi modificare SOLO i file nella WHITELIST FINALE che dichiarerai PRIMA della patch.
- NON chiedere “acconsenti” o conferme intermedie. Se whitelist ok, applica direttamente.
- Se serve toccare file fuori whitelist: scrivi “SERVE FILE EXTRA: <path>” e STOP senza patch.

REGOLE FERREE
- NON creare file nuovi.
- NON eseguire comandi (npm/vite/tsc/firebase).
- NON usare git.
- [Eventuali cartelle vietate: es. “NON toccare src/autisti/*”.]

COMANDI DI ORIENTAMENTO (solo lettura)
1) pwd
2) ls
3) ls src
4) ls src/pages
5) ls src/utils
6) ls src/components
7) rg -n "[keyword1|keyword2|chiave_storage]" src
8) rg -n "[nomePagina|nomeFunzione]" src
9) rg -n "load|mapping|render|isSameDay|toTs" src

PROCESSO OBBLIGATORIO
FASE 1 — ANALISI (lettura libera)
- Trova e stampa i path reali dei file coinvolti:
  A) mapping dati / letture chiavi
  B) rendering UI (tab/lista/card)
- Riporta chiavi lette/scritte e campi usati in UI.
- Individua filtri/condizioni che possono nascondere dati.

FASE 2 — WHITELIST FINALE (scrittura blindata)
- Scrivi:
  “WHITELIST FINALE:”
  - <path1>
  - <path2>
  - <path3>
- Frase obbligatoria:
  “Modificherò SOLO questi file. Nessun altro.”

FASE 3 — PATCH (solo su whitelist)
- Applica le modifiche richieste SOLO nei file whitelist.
- Output obbligatorio:
  1) piano breve (max 10 bullet)
  2) WHITELIST FINALE
  3) diff completo

ESEMPIO SPECIFICO — ADMIN EVENTI AUTISTI (solo Admin, Autisti intoccabili)

OBIETTIVO
In ADMIN:
- Rifornimenti + Segnalazioni: mostra targa (targaCamion + eventuale targaRimorchio) e categoria mezzo via lookup da @mezzi_aziendali usando targaCamion.
- Richieste attrezzature: mostra SOLO autistaNome.
NON modificare src/autisti/*.

COMANDI
1) pwd
2) ls
3) ls src
4) ls src/pages
5) rg -n "@segnalazioni_autisti_tmp|@rifornimenti_autisti_tmp|@richieste_attrezzature_autisti_tmp" src
6) rg -n "@mezzi_aziendali" src
7) rg -n "Admin|AutistiAdmin|Autisti|Event" src
8) rg -n "loadHomeEvents|homeEvents|mapping|isSameDay|toTs" src
9) rg -n "targaCamion|targaRimorchio|autistaNome|categoria" src

VINCOLI
- lettura libera ovunque
- scrittura solo su whitelist finale
- niente “acconsenti”
- se serve altro file: “SERVE FILE EXTRA: <path>” e stop
--- a/workflow_codex_checklist.txt
+++ b/workflow_codex_checklist.txt
@@
 FASE 4 — VERIFICA TECNICA RAPIDA (CTRL+F)
 Prima del test UI, verifica 5 cose nel codice (solo ricerca testo):
 [ ] setItemSync/getItemSync usa la chiave giusta (@...).
 [ ] Update per id: findIndex/find con record.id.
 [ ] Non perde campi: usa spread (...old, ...draft) o patch mirata.
 [ ] Timestamp: normalizzazione (timestamp ?? data ?? ...) se serve.
 [ ] Nessun import sospetto / codice morto enorme.
+[ ] React list keys: nessun warning "Encountered two children with the same key".
+    - Ogni .map deve usare una key stabile e UNICA (preferisci record.id).
+    - Evita index come key se la lista può cambiare ordine o filtrare.
+[ ] VS Code "Problems" pulito: nessun errore TS e niente unused che blocca CI/deploy.
+    - Rimuovere funzioni/variabili inutilizzate o usarle davvero.
 
 ────────────────────────────────────────────────────────────
 FASE 5 — TEST LOCALE (manuale, breve)
 Esegui SEMPRE questi test minimi:
 [ ] Compila e parte in locale.
 [ ] Flusso principale: la feature richiesta funziona.
 [ ] Refresh pagina: i dati restano corretti.
 [ ] Caso negativo: input mancante mostra errore o non rompe.
 [ ] Mobile width: nessun overflow evidente (se UI).
+[ ] Desktop wide: allineamenti ok, nessun "vuoto" da layout (grid che viene spinta da sidebar).
+[ ] Se ci sono sidebar lunghe (es. Stato rimorchi/Sessioni): scroll INTERNO, non deve spingere giù le card centrali.
@@
 COMANDI DI ORIENTAMENTO (solo lettura)
 1) pwd
 2) ls
 3) ls src
 4) ls src/pages
 5) ls src/utils
 6) ls src/components
+7) ls src/autistiInbox
+8) ls src/autistiInbox/components
-7) rg -n "[keyword1|keyword2|chiave_storage]" src
-8) rg -n "[nomePagina|nomeFunzione]" src
-9) rg -n "load|mapping|render|isSameDay|toTs" src
+9) rg -n "[keyword1|keyword2|chiave_storage]" src
+10) rg -n "[nomePagina|nomeFunzione]" src
+11) rg -n "load|mapping|render|isSameDay|toTs|HomeEvent" src
## AGGIUNTE CHECKLIST (NUOVE REGOLE EMERSE)

### 1) Regola “storageSync wrapper vs top-level”
- Se un modulo scrive/legge con `setItemSync/getItemSync`, il documento Firestore in `storage/<KEY>` salva i dati dentro **`value`**.
- Se un modulo legge con `getDoc` diretto (`doc(db,"storage","<KEY>")`) e cerca campi top-level (es. `items`), rischia di non vedere nulla.
- Regola operativa:
  - **O** usi sempre `getItemSync` (e leggi `value`),
  - **O** se vuoi top-level, allora scrivi/leggi con `setDoc/getDoc` e schema top-level coerente.
- Prima di fare patch: controlla in Firestore Console la shape del doc (`value` vs top-level).

### 2) Regola “normalizzazione targa” (spazi + null-safe)
- Tutti i confronti su targhe devono passare da una funzione unica `normalizeTarga`.
- `normalizeTarga` deve essere **null-safe** (mai `.toUpperCase()` su `null/undefined`).
- Normalizzazione consigliata:
  - uppercase
  - trim
  - rimozione spazi: `replace(/\s+/g, "")`
- Usare la stessa normalizzazione sia lato filtro (Dossier/InBox/Admin) sia lato scrittura/aggancio.

### 3) Regola “TypeScript strict” (build Vercel)
- Vietato lasciare errori TS che bloccano build:
  - TS7006 (implicit any)
  - TS2367 (confronto number vs string)
- Regola operativa:
  - tipizzare sempre gli array/record letti da storage con `type`/`interface`
  - nei `sort` su timestamp usare fallback numerico: `(b.data ?? 0) - (a.data ?? 0)`
  - nei confronti usare cast/normalizzazione coerente (Number/String) o check `== null`
- Dopo ogni patch: `Save All` → tab “Problems” deve essere 0 errori.
1) Regola “Autisti vs AutistiInbox” (cartelle e route mai confuse)

Autisti app: src/autisti/* e route /autisti/*

Inbox/Admin: src/autistiInbox/* e route /autisti-inbox/* + /autisti-admin

Convenzione pratica: tutte le pagine “vedi tutto” dell’Inbox devono finire in *All.tsx e stare in src/autistiInbox/.

2) Pre-check routing obbligatorio quando aggiungi una pagina

Prima di qualsiasi patch UI:

controlla in App.tsx:

import del componente giusto (cartella giusta)

route giusta (prefisso giusto)

controlla in AutistiInboxHome.tsx:

il bottone punta alla route giusta

evitare mismatch tipo: route /autisti/... che importa da autistiInbox o viceversa.
3) Regola “Cache / PWA / Vercel” (versione vecchia anche se il codice è giusto)

Sintomo: “non funziona” ma dopo reset cookie/site data funziona.
Prima di toccare file:

Testa in Incognito.

Fai Hard reload (Ctrl+F5).

Chrome DevTools → Application:

Clear storage → Clear site data

(Se PWA) Unregister Service Worker

Su telefono: cancella dati sito (non solo cache) o prova browser diverso.

4) Regola “Foto” (mai affidarsi a Base64 dentro Firestore per uso reale)

Problema tipico: su telefono salvataggi che “non salvano niente” quando c’è la foto.
Regola pratica:

Foto vanno su Firebase Storage.

Nel record salva solo riferimenti leggeri:

fotoUrl e fotoStoragePath (oppure fotoUrls[]/fotoStoragePaths[]).

I reader (Inbox/Admin/All) devono supportare sia:

legacy dataUrl base64

nuovi fotoUrl (Storage)

5) Regola “Windows vs Vercel” (case-sensitive + file mancanti)

Sintomo: in locale funziona, su Vercel fallisce con Failed to resolve import ... .css.
Regole:

Su Vercel (Linux) i path sono case-sensitive.

Verifica SEMPRE:

nome file reale = import (maiuscole/minuscole identiche)

il file esiste davvero nel repo

git status pulito, file aggiunti e pushati

Se sposti file tra cartelle, aggiorna tutti gli import relativi.

6) Regola “Separazione Autisti vs AutistiInbox” (mai mischiare route/import)

Obiettivo: evitare che una route Autisti punti a un componente Inbox (o viceversa).
Check rapido:

/autisti/* importa da src/autisti/*

/autisti-inbox/* importa da src/autistiInbox/*

Se rinomini in *All.tsx in Inbox, anche import/route devono usare *All.

7) Regola “Create lavoro da segnalazione/controllo” (dedup obbligatorio)

Quando crei un lavoro da Admin:

scrivi linkedLavoroId (o linkedLavoroIds) nel record sorgente

imposta anche stato/letta per “presa in carico”

per controlli target="entrambi": 2 lavori (motrice + rimorchio) se targhe presenti

normalizza sempre targa: toUpperCase().trim()

8) Regola “Deploy”

Modifiche solo frontend (src/**) → nessun deploy functions.

Deploy functions solo se tocchi functions/** e relative chiamate.
────────────────────────────────────────────────────────────
AGGIUNTE CHECKLIST (NUOVE REGOLE EMERSE)

1) Regola “storageSync wrapper vs top-level”
- Se un modulo scrive/legge con setItemSync/getItemSync, il doc Firestore storage/<KEY> salva i dati dentro "value".
- Se un modulo legge con getDoc diretto (doc(db,"storage","<KEY>")) e si aspetta campi top-level (es. items), rischia di non vedere nulla.
- Regola operativa:
  - O usi SEMPRE getItemSync/setItemSync (e leggi/scrivi value)
  - O se vuoi top-level, allora usi setDoc/getDoc con schema top-level coerente.
- Prima di patch: controlla in Firestore Console la shape reale del doc (value vs top-level).

2) Regola “normalizzazione targa” (null-safe)
- Tutti i confronti su targa devono passare da normalizeTarga (null-safe: mai .toUpperCase() su null/undefined).
- Normalizzazione consigliata:
  - uppercase
  - trim
  - rimozione spazi: replace(/\s+/g, "")
- Usare la stessa normalizzazione in scrittura e in lettura (Dossier/InBox/Admin).

3) Regola “TypeScript strict” (build Vercel)
- Vietato lasciare errori TS che bloccano build (TS7006, TS2367, ecc.).
- Regola operativa:
  - tipizzare array/record letti da storage con type/interface
  - sort su timestamp con fallback numerico (bTs - aTs) e fallback a 0
  - nei confronti number/string usare normalizzazione coerente (Number/String) o check null.
- Dopo ogni patch: Save All → tab “Problems” deve essere 0 errori.

4) Regola “Autisti vs AutistiInbox” (cartelle e route mai confuse)
- App Autisti: src/autisti/* e route /autisti/*
- Inbox/Admin: src/autistiInbox/* e route /autisti-inbox/* + /autisti-admin
- Convenzione: tutte le pagine “Vedi tutto” Inbox finiscono in *All.tsx e stanno in src/autistiInbox/.

5) Pre-check routing obbligatorio quando aggiungi una pagina
- Prima di qualsiasi patch UI:
  - controlla in App.tsx: import del componente giusto (cartella giusta) + route con prefisso giusto
  - controlla in AutistiInboxHome.tsx: i bottoni puntano alle route giuste
- Evitare mismatch tipo: route /autisti/... che importa da autistiInbox o viceversa.

6) Regola “Cache / PWA / Vercel” (versione vecchia anche se il codice è giusto)
- Prima di toccare file:
  - test in Incognito
  - Hard reload (Ctrl+F5)
  - DevTools → Application → Clear site data
  - (se PWA) Unregister Service Worker
  - su telefono: cancella dati sito, non solo cache.

7) Regola “Foto” (mai Base64 in Firestore per uso reale)
- Foto su Firebase Storage.
- Nel record salva solo riferimenti leggeri:
  - fotoUrl e fotoStoragePath (oppure fotoUrls[]/fotoStoragePaths[]).
- Reader (Inbox/Admin/All) devono supportare:
  - legacy dataUrl base64
  - nuovi fotoUrl da Storage.

8) Regola “Windows vs Vercel” (case-sensitive + file mancanti)
- Su Vercel (Linux) i path sono case-sensitive.
- Verifica sempre:
  - nome file reale = import (maiuscole/minuscole identiche)
  - il file esiste nel repo
  - git status pulito, file aggiunti e pushati.

9) Regola “Create lavoro da segnalazione/controllo” (dedup obbligatorio)
- Quando crei un lavoro da Admin:
  - scrivi linkedLavoroId (o linkedLavoroIds) nel record sorgente
  - imposta stato/letta = “presa in carico”
  - per controlli target="entrambi": 2 lavori (motrice + rimorchio) se targhe presenti
  - normalizza sempre targa.

10) Regola “Deploy”
- Modifiche solo frontend (src/**) → nessun deploy functions.
- Deploy functions solo se tocchi functions/** e relative chiamate.
────────────────────────────────────────────────────────────
